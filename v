Задача 2

2.1

Пусть масса меда и дегтя в ложке = 20 грамм и масса бочки = 2000 грамм

Тогда концентрация дегтя в бочке с медом = 20/(2000+20) = 0.00990099
а концентрация меда в той же бочке 1-(20/2020) = (2020-1)/2020

Содержание меда в ложке, которую взяли из бочки с медом после добавления дегтя
20*(2019/2020) = 19.8 гр

Значит, концентрация меда в бочке дегтя = 19.8/2000= 0.0099

Ответ: Концентрация дегтя в бочке с медом в которую положили деготь,
больше концентрации меда в бочке с дегтем на 0.00000099 гр

2.1
Пусть обьем бочки с дегтем в n раз больше бочки с медом,
С дегтем: n*2000
С медом: 2000

Концентрация дегтя в бочке с медом как в первом вопросе, = 0.00990099
А меда в дегте: 19.8/n*2000 = 0.0099/n , то есть в n раз меньше чем в одинаковых бочках

Обратный вариант:
с дегтем: 2000
с медом: n/2000

Концентрация дегтя в бочке с медом = 20/(n/(2000+20)) = 20/n/2020 = 1/n/101
Концентрация в n раз меньше чем в варианте с одинаковыи бочками

Содержание меда в ложке, которую взяли из бочки с медом после добавления дегтя
20*(100/n*101) = 19.8/n гр

Значит, концентрация меда в бочке дегтя = (19.8/n)/2000= 0.0099/n


Полный ответ:
2.1) Ответ: Концентрация дегтя в бочке с медом в которую положили деготь,
больше концентрации меда в бочке с дегтем на 0.00000099 гр
2.2)
1. Если бочка с дегтем будет в n раз больше бочки с медом,
то концентрация дегтя в бочке с медом не изменится, а концентрация меда
в бочке дегтя уменьшится в n раз
2. Если бочка с медом будет в n раз больше бочки с дегтем,
то концентрация дегтя в бочке с медом уменьштся в n раз и концентрация меда
в бочке дегтя уменьшится в n раз


Петеримов Александр
9 Мастерская





# 1.1
Первый квадрат 210*210
Остаётся прямоугольник 210*87
Из него выделяем 2 квадрата 87*87
Остаток 87*36
Два квадрата 36*36
Остаток 15*36
Два квадрата 15*15
Остаток 6*15
Два квадрата 6*6
Остаток 3*6
Два квадрата 3*3, то есть, одинацатый последний квадрат это 3*3, его площадь 9 КВ мм







# Получаем длину и ширину листа
s = input().split('x')
a = int(s[0]) # длина
b = int(s[1]) # ширина

c = 0 #создаем переменнную для записи данных
#Создаем цикл в котором сравниваем данные

for i in range(a):
    if a > b:
        c += 1# записываем шаги
        a -= b# отнимаем ширину от длины
    elif a < b:
        c += 1# записываем шаги
        b -= a# отнимаем длину от ширины

#выводим результат
print(c+1)
print(a*b)








a = input()
lst = []
open = '{(['
close = '})]'

err = 0


for i in a:
    if i in open and i == '(':
        lst.append(i)
    elif i in close and i == ')':
        try:
            lst.remove('(')
        except ValueError:
            print("Wrong")
            err = 1
            break
    elif i in open and i == '[':
        lst.append(i)
    elif i in close and i == ']':
        try:
            lst.remove('[')
        except ValueError:
            print("Wrong")
            err = 1
            break
    elif i in open and i == '{':
        lst.append(i)
    elif i in close and i == '}':
        try:
            lst.remove('{')
        except ValueError:
            print("Wrong")
            err = 1
            break






if lst == [] and err == 0:
    print('Right')
elif err == 1:
    print()
else:
    print('Wrong')









#Алгоритм на O(n**2)

str = input().split() #Принимаем данные
count = 0 #Переменная для подсчета шагов
lst = [] #Пустой массив

#Добававляем в массив числа из input
for i in str:
    lst.append(int(i))

#Создание цикла
while lst != []:#Если цикл будет пуст, он остановится
# Сортировка 'пузырьком'
    for i in range(len(lst)-1):
        for j in range(len(lst)-i-1):
            if lst[j] > lst[j-1]:
                lst[j], lst[j-1] = lst[j-1], lst[j]

         #Проверка
        if lst[0] > 0: #Если первый элемент из отсортированного массива больше одного, то мы отнимаем 1 от последнего и первого элемента и считаем шаги
            lst[2] -= 1
            lst[0] -= 1
            count += 1
        elif lst[0] == 0 and lst[2] > lst[1] and lst[1] > 0: #Если первый элемент из отсортированного массива равен нулю, а последний элемент больше предпоследнего, то мы отнимаем 1 от последнего и предпоследнего элемента и считаем шаги
            lst[2] -= 1
            lst[1] -= 1
            count += 1
        elif lst[0] == 0 and lst[1] > lst[2] and lst[2] > 0: #Если первый элемент из отсортированного массива равен нулю, а последний элемент меньше предпоследнего, то мы отнимаем 1 от предпоследнего и предпоследнего элемента и считаем шаги
            lst[1] -= 1
            lst[2] -= 1
            count += 1
        else: # в остальных случаях останавливаем цикл
            break
    if lst[0] == 0 and lst[1] == 0 or lst[1] == 0 and lst[2] == 0 or lst[2] == 0 and lst[0] == 0: # Если любых 2 элемента из массива равны нулю, то останавливаем цикл
        break




print(count) # выводим результат




#Алгоритм на О(n)
str = input().split()
a = int(str[0])
b = int(str[0])
c = int(str[0])
result = (a+b+c)//2

print(result)













